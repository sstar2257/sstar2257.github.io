---
title: C++类型转换 
date: 2019-08-15 23:33:04
updated: 2019-08-15 23:33:04
tags: [c++11, c++]
---

## 基本数据类型转换规则

+ 浮点型数据赋值给整型变量时，舍弃小数部分
+ 整型数据赋值给浮点型数据时，数值不变但是以指数方式存储
+ 字符型数据以ASCII码的形式赋值给整型变量
+ long、int、short、char向下赋值时，会舍弃高位数据
+ 有符号数赋值给一个无符号类型时，不做转换直接进行内存拷贝，所以一个很小的负数可能变成一个很大的正数

## C++的四个强转关键字

### static_cast  

用法：static_cast <类型说明符> （变量或表达式）
1. 用于基本数据类型之间的转换，安全性需要开发人员自己保证  
2. 将void\*指针转换成目标类型的指针（注意只能是void\*，类似int\*到char\*之类的转换会被编译器阻止，然后在C语言中进行基本类型指针之间的强转是被接受的）  
    > 空指针与void\*指针（通用变体类型指针）是不同的！
    > void \*可以指向任何类型对象的地址，表示这是一个指针，和地址有关，但是不知道该地址上的对象的类型。void\*指针不能直接解引用，必须先赋值给其他任何类型的指针，或者强转为一个具有实际类型的指针。malloc返回的即该指针。 
    > 空指针表示的是指向一个"空"的地址，即不存在的地址（具体实现为指向地址为0的内存（void \*）0，该地址的内存不可被访问），对空指针解引用会因为不存在具体的地址而失败。   
	> > btw提一下野指针和悬挂指针：
    > > 野指针：指向垃圾内存的指针：  
    > > &nbsp;&nbsp;-未初始化的指针变量
    > > &nbsp;&nbsp;-被free或delete之后没有制NULL的指针
    > > &nbsp;&nbsp;-越界指针
    > > 悬挂指针：
    > > 上述的第二种情况
3. ~~把任何类型的表达式转换为void类型~~（实际很少用到，static_cast<void>(param)不产生任何结果，但是可以阻止编译器产生unused警告）
4. 用于类层次结构中基类和派生类之间指针或引用的转换（不进行安全性检查）
    - 上行转换是安全的（将一个派生类的指针或引用赋给基类指针或引用）
    - 下行转换不能保证安全  
  

<!-- more -->
### dynamic_cast  

四种转换中只有dynamic_cast是在运行时处理的（其他三种都在编译时完成），在运行时会进行安全性检查。
- 不能进行基本数据类型的强制转换，<>内的类型要求必须为指针或引用
- 对基类或派生类进行转换时，基类必须具有虚函数，否则编译不通过（只有基类中有虚函数时，这种转换才有意义）

> 出错的原因在于：**运行时类型检查需要运行时类型信息，而这个信息存储在类的虚函数表**  
> 在类的转换时，进行上行转换与static_cast一致，但是在下行转换时，dynamic_cast具有类型检查的功能。即**要转换的指针指向的对象的实际类型与转换以后的对象类型一定要相同，否则转换失败，返回空指针**（即把一个指向基类对象的指针赋值给派生类对象的指针时，会返回空指针，但是若这个基类指针指向的是一个派生类，则能成功赋值）
> 值得特别注意的是，指针的类型和变量一样，都是在定义的时候被确定了，无论指向怎么改变，指针的类型本质不变。比如
```c
char *p = (char *)new int(1);
p = (char *)new double(1.0);
//不管给p赋什么值，对p解引用都是只取一个字节
```
  

### const_cast  

去除const特性，值得特别注意的是，const_cast不是去除变量的常量性，而是去除指向这个常量的常指针或常引用的常量性。（只有常指针和常引用可以指向一个常量，否则编译错误）

> 去除常量性的用处：
```
void func(const char* str){
	...;
}
void func2(char* str){
	...;
}
```
> func可以传入一个const char\* 指针，同时也可以传入一个char \*指针；
> 相反的，若向func2传入一个const char\* 指针，编译报错。 
这么设计的目的就是为了确保const变量不被修改。在这种时候就可以使用const_cast去掉指针的常量性。

**const_cast<type_id> (expression)**：除了const或volatile属性，type_id和expression一致。
> 虽然说常量一旦被定义之后无法修改，但是通过const_cast，存在一种可能性，通过被去除const属性的指针，间接地去修改一个常量的值。且这样做不会被编译器阻止，但是这种行为的后果是未定义的。
> 可能出现的结果就是，当一个常量通过上面的方式被修改之后，这个常量的地址和指针的地址虽然指向同一个地方，但是打印出来的值却会不一样。（编译时编译器可能会把常量当做立即数处理了，但具体看编译器实现）。
> const在C语言中是表示**道义上保证变量的值不会被修改**，并不能实际阻止修改。  
  

### reinterpret_cast  

**用法：reinterpret_cast<type_id> (expression)**  

type-id必须是一个指针、引用、算术类型、函数指针或者成员指针。
它可以把一个指针转换成一个整数，也可以把一个整数转换成一个指针（先把一个指针转换成一个整数，在把该整数转换成原类型的指针，还可以得到原先的指针值）。
   - 改变指针或引用的类型
   - 将指针或引用转换为一个足够长度的整形
   - 将整型转换为指针或引用类型
语义就是重新解释，最类似C中的一个也是最任意的一个强制转换，**强制转换过程仅仅只是比特位的拷贝**，所以容易出问题。
